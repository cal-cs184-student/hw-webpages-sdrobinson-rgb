<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
				background-color: #181A1B;
				color: white; 
			}
			a:link {
				color: skyblue;
			}
			a:visited {
				color: mediumorchid;
			}
			code {
				color: chartreuse;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184 Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Name: Skylar Robinson</div>

		<br>

		Link to webpage: <a href="https://cal-cs184-student.github.io/hw-webpages-sdrobinson-rgb/">cal-cs184-student.github.io/hw-webpages-sdrobinson-rgb</a>
		
		<br>

		Link to GitHub repository: <a href="https://github.com/cal-cs184-student/hw1-rasterizer-skythelar">github.com/cal-cs184-student/hw1-rasterizer-skythelar</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>The homework 1 lion looks down upon this write-up.</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<p>In Task 1, I implemented a simplified tringle rasterization algorithm which took a single sample from the middle 
		of each point in the bounding box of the triangle. My code performed three line tests (one for each side of 
		the triangle) that determined whether the point being sampled was on the side of the line inside the triangle or
		not, coloring the point if all three tests passed and leaving it alone otherwise. The line test I used computed the dot
		product of the vector formed between the given point and the 'first' point on a side with the normal vector of the side;
		if the dot product was positive (or zero, since that meant it was on the line), the point passed the line test.</p>
		
		<p>To account for a difference of clockwise and counterclockwise vertex points provided to the function, I calculated the normal
		vectors first under the assumption that the points where given in counterclockwise orientation, then reversed all three normal
		vectors if the function found that the third point didn't pass the line test for the first side (any point on the triangle must
		pass all three line tests by definition, so if this test failed then the normals faced the wrong way).</p>

		<p>The running time of this algorithm is no worse than checking each sample within the bounding box because that's exactly
			what it does. My implementation of the function involves finding the edges of the bounding box of the triangle by taking
			the maximum and minimum of the x and y values for all three points, the x range determining the left and right sides
			of the bounding box and the y range determining the top and bottom. When running the line tests on the points, the for loops
			I used to iterate through the points start at the beginning of the bounding box and end at the other edge (going from left
			to right and top to bottom, in the direction of increasing coordinates on both axis).
		</p>
		
		<figure>
			<img src="screenshot_2-17_17-42-54.png" alt="test 4 rendered without supersampling" style="width:50%"/>
			<figcaption>Here is test4.svg rendered using this method. The pixel <br>
				inspector shows the bottom left vertex of the green triangle.
			</figcaption>
		</figure>

		<!--
		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		-->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		<p>
			The supersampling algorithm makes use of the sample buffer, which stores a color data point for every sample taken.
			As such, its size is the number of pixels in the frame buffer (AKA the screen) multiplied by the sample rate. The triangle
			rasterization from Task 1 now writes to the sample buffer, taking multiple samples per point as determined by the sample
			rate. To implement supersampling when rendering the sample buffer, I had to alter the provided implementation of the
			<code>resolve_to_framebuffer</code> function so that it took an average of all sample buffer points within a framebuffer
			pixel, as opposed to reading directly from the sample buffer (which only works when the sample rate is 1). Some other
			changes include altering the provided <code>rasterize_point</code> function to write to the entire square of samples
			representing that point in the sample buffer, and implementing the functions that resized the sample buffer when the
			sample rate changed.
		</p>

		<p>
			Supersampling is useful since it reduces jagged edges and artifacts that rendering low resolution objects would
			otherwise create. By averaging multiple samples for every pixel, supersampling reduces the chance for small
			details to either be overrepresented by a sample, or missed entirely. It also blends sharp edges, which reduces
			any staircase artifacts.
		</p>

		<p>
			The main trade off in supersampling is memory usage, as we now have to store an increasingly scaled number
			of data points in the sample buffer. Additionally, there is a computational cost in averaging the sample buffer
			points, as in the non-supersampling rasterization pipeline, all calculations are done by the rasterization
			functions, and <code>resolve_to_framebuffer</code> simply read from the sample buffer. In the supersampling
			pipeline, however, the rasterization functions collect data, and <code>resolve_to_framebuffer</code> must
			process the data (by averaging samples) to create something displayable.
		</p>

		<p>
			Supersampling antialiased my triangles by taking multiple samples for every pixel in my triangle
			rasterization method. This practice results in antialiasing as it smooths the edges of the rendered
			triangles for the same reasons described above. The effect of this antialiasing can be seen in the
			screenshots below.
		</p>

		<p style="text-align: center">test4.svg rendered at different supersampling frequencies;<br>
		   the pixel inspector shows the rightmost corner of the red triangle.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_17-53-15.png" width="330px"/>
				  <figcaption>1 sample per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_17-53-21.png" width="330px"/>
				  <figcaption>4 samples per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-17_17-53-24.png" width="330px"/>
				  <figcaption>16 samples per pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h2>Task 3: Transforms</h2>
		For Task 3, I added the implementations for three transformation functions: <code>translate</code>,
		<code>scale</code>, and <code>rotate</code> using matrix multiplication. Here is my edit of
		robot.svg using these functions:

		<figure>
			<img src="screenshot_2-17_19-10-56.png" alt="cubeman with boots catching the bus" style="width:50%"/>
			<figcaption> He is running after the bus while waving to get <br>
				the driver to stop! Also I gave him boots.
			</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>